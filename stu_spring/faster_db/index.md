# DB Index

### Index란?

**추가적인 공간**을 활용해서 **조회의 성능 향상**을 위해 사용되는 자료구조 이다.

> 만약 index가 없을 때 id가 10000인 데이터를 찾으려면, 테이블의 모든 데이터를 순회하며 찾아야 한다.

Index란 **지정한 컬럼**을 기준으로 **목차**를 생성하는 것으로, **조회의 성능 향상**을 목적으로 사용된다.

반대로 삭제, 수정, 삽입의 성능은 떨어지게 된다.

> 원래 수정, 삭제는 작업 전 조회를 하게 되는데, 여기서 전체적인 작업(조회 + 삭제)이 느려지는게 아니라 삭제 작업만 느려지게 된다.
>
> 즉 **전체적인 수정/삭제 작업의 속도가 느려진다는건 아니고, 오히려 빨라진다.**



다음과 같은 구조를 갖는다.

![index_basic](.\images\index_basic.jpg)

즉 인덱스를 사용하게 되면 직접 테이블에 접근하는게 아니라, **INDEX를 통해 실제 테이블에 간접적으로 접근한다.**

인덱스에 접근한 후에, KEY - VALUE 형태로 되어있는 INDEX에서 **주소를 찾아 실제 테이블에 접근한다.**



#### 성능이 느려지는 이유

DBMS가 조회를 사용하려 하면 INDEX를 항상 최신 상태로 유지해야 한다.

> 삽입이 일어났는데 INDEX가 수정되지 않았다면, INSERT된 값은 조회 결과로 들어오지 않기 때문이다.

따라서 삽입, 수정, 삭제 시에 **INDEX를 수정하기 위한 추가 오버헤드가 발생한다.**

- 삽입

  새로운 데이터를 인덱스에 추가한다.

- 삭제

  삭제된 데이터의 인덱스를 **사용하지 않도록 함**

- 수정

  기존의 인덱스를 **미사용 처리**하고 **갱신된 데이터를 인덱스에 추가**한다.



### INDEX의 장단점

#### 장점

- 테이블 조회 성능을 증가시킬 수 있다.

- 전반적인 시스템의 부하를 줄일 수 있다.

  만약 INDEX가 없을 때 FULL SCAN이 발생할 상황을 훨씬 쉽고 부하가 적게 조회한다.

#### 단점

- 인덱스를 관리하기 위한 공간이 필요하다.

  > DB의 10% 정도 차지하게 된다.

- 인덱스 관리를 위한 추가 작업이 필요하다.

- 잘 못 사용할 경우, 오히려 성능이 저하될 수 있다.

  이유는 삭제와 수정이 인덱스를 **삭제하지 않고 사용하지 않음 처리하기 때문이다.**

  즉 수정 삭제가 빈번한 테이블에 인덱스를 사용하게 되면 **실제 데이터보다 훨씬 더 많은 인덱스 때문에 성능이 저하된다.**

따라서 사용하지 않는 인덱스는 지워주는게 좋다.



### 인덱스를 사용하면 좋은 경우

- 규모가 큰 테이블
- 삽입, 수정, 삭제가 자주 일어나지 않는 컬럼
- JOIN, ORDER BY, WHERE이 자주 일어나는 컬럼
- 데이터 중복도가 낮은 컬럼



### 자료구조

#### Hash 인덱스 알고리즘

**컬럼의 해시 값**을 계산해서 인덱싱 하는 알고리즘

하지만 값을 변형하기 때문에, `like`나 `<`(부등호 연산)의 사용이 불가능하다.

주로 메모리 기반 데이터베이스 (redis 등)에서 사용된다.

시간 복잡도가 O(1)로, 굉장히 빠르다.



#### B+Tree 알고리즘

B Tree의 알고리즘의 변형된 형태로, 기존의 B Tree가 노드에 key와 value를 저장했던 것에 반해 B+Tree는 **노드에 key만 담아두고, value는 저장하지 않는다.**

오직 리프 노드에만 데이터를 저장하기 때문에 메모리를 더 확보할 수 있고, 더 많은 key들을 수용할 수 있다는 장점이 있다.



<img src=".\images\bplustree.jpg" alt="bplus" style="zoom: 80%;" />

대부분의 인덱싱 알고리즘에서 사용된다.

특정 컬럼의 값을 변형하지 않고 원래 값을 이용해 인덱싱 한다.

즉 **`like`를 통한 검색이나 부등호 탐색이 가능**하기 때문에 index에서 사용할 때, 동등 연산에 특화된 해쉬 알고리즘보다 인덱스에 적합하다.



