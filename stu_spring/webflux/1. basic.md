# WebFlux 기초

## Reactive Stream

---

Reactive Stream는 **non-blocking과 backPressure을 이용한 비동기 스트림 처리를 위한 표준**이다.

> Reactor와 RXJava는 Reactive Stream의 구현체 이다.



### Reactive Stream의 목적

Reactive Stream의 목적은 **동기와 비동기의 경계를 명확히**하여 **Stream 데이터 교환을 효과적으로 관리**하는데에 있다.

즉, 어느정도의 data가 특정 시스템에 들어오는지 **예측 가능**하게 하는것이 목적인데, backPressure가 중요한 역할을 한다.



#### BackPressure란

여기서 backPressure란, Input 작업에서 Output 작업으로, Output 작업에서 Input 작업으로 변환될 때 **어떠한 방법으로 변환에 저항하는 것**이라고 할 수 있다.

이렇게 변환에 저항하는 일은 주로 **input이 들어오는 속도가 Output만큼 빠를 때** 일어난다.	



아직도 BackPressure에 대한 개념은 감을 잡기 힘들다. 그렇기 때문에 간단한 예제를 들어 설명해 보자



한 사람이 컨베이어 벨트에서 물건을 골라, 포장하는 일을 맡고 있다.

굉장히 쉬운 작업이지만, 컨베이어 벨트의 속도가 그 사람이 따라잡을 수 있을 정도의 속도였을 때의 이야기 이다.

그래서 그 사람은, 2가지 방법을 채택해서 해결하려 했다.

- 물건을 컨베이어 벨트에서 꺼내, 옆에 올려두어 나중에 처리한다.
- 물건을 부수어서 처리할 일을 줄였다.



이렇게 2가지 방법은 각각 **Buffering**과 **Dropping**에 비유될 수 있다.

하지만 공장에서 이러한 작업은 허용될 수 없다.

따라서 사람은 컨베이어 벨트의 속도를 조정하는 방법이 최선이다.



이제 예제를 소프트웨어 세계로 돌려보자.

최근에 많이 사용되고 있는 MSA에서는 서버간의 통신이 잦다.

BackPressure는 하나의 서버가 다른 서버가 처리할 수 있는 속도보다 빠른 속도로 요청을 보내면 발생한다.



만약 한 서버에서 다른 서버로 초당 100개의 요청을 보내지만 요청을 받는 서버는 초당 75개의 요청만 처리할 수 있다면 초당 25개의 요청 만큼 손실이 발생한다.

![image-20210520194631697](./images/backpressure_msa.png)

위와 같이 100개의 요청을 받는 서버는 계속해서 뒤쳐질 수도 있다.

위에서 예제로 들었듯이, 2가지 방법으로 대처할 수 있다.

- Buffering

  초당 25개의 요청을 Buffer시켜서 손실을 발생시키게 된다.

  하지만 계속해서 쌓이게 되면 OutOfMemory가 발생해서 down될 우려가 있다.

- Dropping

  요청을 계속해서 없애버리면 된다.

  하지만 요청을 아예 Drop하는건 허용될 수 없다.



따라서 위 두 방법들은 좋은 방법이 될 수 없다.

그렇다면 가장 이상적인 방법은 요청을 받는 서버에서 요청을 보내는 서버의 **요청 속도를 조절**하는 것이다.

하지만 이것은 항상 가능한 방법이 아니다.

만약 요청을 보내는 서버가 사용자를 대신해 요청을 보내는 것이라면, 계속 기다리라고 할 수 없다.

하지만 상황에 따라 속도를 늦출 수 있다.

하지만 웬만하면 Buffer를 두는게 좋은 상황이 많다.



Reactive는 들어본적 없더라도, Stream은 들어본적 있을 것이다.

Stream이란 직역하면 `흐름`으로, 시간이 지나면서 생성되는 일련의 신호 이다.

> 데이터/이벤트/신호는 모두 같은 의미이다.
>
> 때에 따라 다르게 쓰이지만, Reactive Streams 스펙에선 Signal을 사용한다.

Streams는 다음 신호들을 보낼 수 있다.

- onNext

  데이터 발행을 의미한다.

- onComplete

  모든 데이터의 발행이 완료되었음을 의미한다.

  onComplete발생 이후에는 onNext가 발생하지 않는다.

- onError

  에러가 발생했음을 알린다.

  이후에는 observable이 종료된다.



우리는 0개 이상의 onNext 신호를 만들 수 있고, 해당 신호는 데이터를 담는다.

이렇게 데이터 발행이 성공하면 onComplete, 에러가 발생하면 onError 신호가 발생하는데, onComplete와 onError는 발생하지 않을 수 있다.



## WebFlux란?

---

기존의 Spring과 달리, **비동기 논블록킹**을 통해 **적은 수의 쓰레드로 빠른 응답 속도**를 위해 만들어진 모듈이다.



## 비교

---

### RXJava

RXJava는 JVM을 위한 **ReactiveX(Reactive Extensions)** 라이브러리로, **함수형 프로그래밍**이다.

여기서 Reactive란 **비동기적 데이터 흐름을 처리하는 프로그래밍**을 말한다.

자바는 함수형 프로그래밍 언어가 아니기 때문에 순수 함수로 된 리액티브 연산자를 제공한다.

Netflix가 오랫동안 Reactive패턴을 이용하면서 Netflix/RxJava가 오픈소스로 공개되었다.



### Reactor

Reactor는 Spring을 만든 팀이 만든 Java Framework이다.

Reactive IO 프로젝트는 