# 코루틴 기본 개념

Coroutine은 **Blocking 방식의 코드로 Non Blocking 코드**를 짜기 위해서 등장한 개념이다

우선 Main Routine과 Sub Routine이라는 개념에 대해서  알아보자

<img src="./images/63651600-6a5a5100-c791-11e9-87d1-3f81dc9b415d.png" alt="image" style="zoom:33%;" />

위와 같이 Main Routine과 Sub Routine이 있을 때, 일반적인 코드의 흐름은 다음과 같다.

<img src="./images/63651648-f8ced280-c791-11e9-9917-1b034b855e84.png" alt="image" style="zoom: 33%;" />

정말 단순하게 메소드가 시작되면 Routine에 진입하고, return을 만나면 Routine에서 빠져나오게 된다.

코드로 보면 다음과 같다고 할 수 있다.

<img src="./images/63651659-303d7f00-c792-11e9-9aae-0b756bb5e8a8.png" alt="img" style="zoom:33%;" />

<br>

하지만 코루틴은 다음과 같은 흐름을 가진다.

<img src="./images/63651705-a0e49b80-c792-11e9-9924-eb737b813065.png" alt="img" style="zoom:33%;" />

Coroutine A라는 함수가 존재할 때, 이 함수는 **진입점과 탈출점이 여러개**이다.

코루틴은 이렇듯 **Return을 만나지 않더라도 Routine에서 탈출**할 수 있고, **다시 Routine에 돌아와서 원래 하던걸 이어서 할 수 있도록 기억**해준다.

<br>

좀 더 자세히 보면 다음과 같다.

<img src="./images/63651752-5fa0bb80-c793-11e9-80e7-9384265cf442.png" alt="img" style="zoom:33%;" />

1. Thread의 main이 되는 메소드가 `startCoroutine {}`을 만나면 Coroutine Block을 생성한다.
   이 블록은 위에서 소개했듯이 언제나 진입하고, 탈출할 수 있다.

   > 여기서 `startCoroutine {}`이라는 Block은 원래 코루틴에 존재하는 Block이 아니지만, 이해를 돕기 위해서 사용했다.

2. Coroutine Block이 suspend가 붙은 `drawHead()`메소드를 호출한다.

3. Coroutine Block을 탈출해서 다른 Thread에서 Head를 그린다.
   메인 쓰레드는 계속해서 다른 작업을 진행한다.

4. drawHead가 끝나면 다시 Coroutine Block으로 돌아와서 다음 작업`drawBody()`를 실행한다.

## Coroutine의 Continuation

*코루틴이 어떻게 작업을 멈추고 다시 시작하냐*라는 질문에 대한 대답은 **실행을 멈추고, 그때의 상태를 저장**함으로써 다음에 다시 이어서 실행할 수 있도록 한다.

이를 위해서 코루틴에서는 다음과 같은 Continuation이 있다.

``` kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext
    
    public fun resume(value: T)
    
    public fun resumeWithException(exception: Throwable)
}
```

여기서 CoroutineContext는 **작업을 실행할 쓰레드를 결정**하도록 돕는 객체이다.



<br>

만약 코루틴을 사용할 때 `suspend`를 붙인 다음과 같은 메소드가 있다고 가정하자.

``` kotlin
suspend fun fetchUserDetail(id: Long) {
    val token = auth()
    val user = getUser(token.id, id)
    
    updateUserData(user)
}
```

위 메소드를 컴파일하면 다음과 같은 코드가 된다

``` kotlin
fun fetchUserDetail(id: Long, cont: Continuation) {
    val stateMachine = object : CoroutineImpl {
        fun resume(stateMachine) {
            this(stateMachine)		// 자신을 다시 시작해 준다.
        }
    }
    switch(stateMachine.label) {
        case 0:
        	stateMachine.id = id		// 다음에도 실행할 수 있도록 정보 저장
        	stateMachine.label = 1		// 다음에 실행할 위치
	        sm.result = auth(sm)
        case 1:
        	val id = stateMachine.id
        	val token = sm.result as String
        	stateMachine.label = 2
        	getUser(token, id, sm)
        case 2:
        	updateUserData(user, sm)
    }
}
```

위와 같이 **이전의 실행 정보`(Continuation)`를 파라미터로 받고, sm에 이전 실행 결과를 저장**한다.



[설명의 원본 주소](https://wooooooak.github.io/kotlin/2019/08/25/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B0%9C%EB%85%90-%EC%9D%B5%ED%9E%88%EA%B8%B0/)

[코루틴은 어떻게 동작하는가?](https://www.youtube.com/watch?v=usaD7HyN598)
