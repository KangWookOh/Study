# 서론

suspending은 Kotlin Coroutine의 특징이다.

이 챕터의 목적이 *`suspensionion은 어떻게 동작하는가`*인 이유도 Suspension은 다른 모든 개념들의 기초가 되는 기능이다.

<br>

suspension이란 게임의 세이브 - 로드처럼 **함수를 호출 중간에 멈추고 실행하는 것**이다.

Koroutine에서 메소드가 suspend되면 `Continuation`객체를 반환하게 되는데, 나중에 멈췄던 곳 부터 다시 실행할 수 있다.

여기서 Thread와 다르다는걸 알 수 있는데, **Thread는 멈출 수 없고, Blocking될 뿐이다.**

반면에 suspend되었을 때에는 다음과 같은 장점이 있다.

- **자원을 전혀 소모하지 않는다.**
- **다른 Thread에서 실행될 수 있다.**
- `(이론상)`**직렬화 후 역직렬화를 한 후에도 재실행할 수 있다.**

# Resume

이제 예제로 살펴보자.

그러기 위해선 나중에 소개할 coroutine builder`(runBlocking, launch)`를 이용해서 coroutine을 만들어줘야 한다.

하지만, 예제를 위한 것 이기 때문에 main 함수를 suspend하면 된다.

<br>

suspend 함수들은 **suspend될 수 있는 함수들**을 의미한다.

즉, **suspend 함수는 Coroutine 또는 다른 suspend에서 실행**되어야 한다.

Main 함수는 시작점이기 때문에 우리가 그걸 실행할 때, Coroutine이 시작되게 된다.

<br>

``` kotlin
suspend fun main() {
    println("Before")
    println("After")
}
```

Before와 After를 출력하는 간단한 프로그램이다.

여기서 suspend를 테스트하기 위해 Kotlin에서 제공하는 `suspendCoroutine`을 추가했다.

``` kotlin
suspend fun main() {
    println("Before")
    suspendCoroutine<Unit> { }
    println("After")
}
```

프로그램을 실행하게 되면 After가 출력되지 않는다.

또한, Main 함수가 끝나지 않고 계속해서 실행될 것이다.

Coroutine은 Before를 출력한 후에 `suspendCoroutine`을 만나 suspend되었지만 다시 Resume되지 않기 때문에 멈추게 된다.

즉, 게임에서 일시정지를 한 후에 재생 버튼을 누르지 않은 상태인 것이다.

<br>

그렇다면 어떻게 재생 버튼을 누를 수 있을까?

Resume을 위한 Continuation은 어떻게 받아올 수 있을까?

자세히 보면 `suspendCoroutine`은 람다 표현식을 파라미터로 받는걸 알 수 있다.

해당 람다 표현식은 **continuation을 Argument로 받고,** Before가 실행된 후, 즉 **main 메소드가 suspend된 후에 실행**된다.

`suspendCoroutine`을 통해 suspension 직전에 continuation 객체를 사용할 수 있다.

이 람다 표현식은 **Continuation을 저장하거나 다시 실행시킬 계획을 세울 때 사용된다.**

<br>

이 Continuation 객체를 사용해서 suspend된 메소드를 다시 실행시킬 수 있다.

``` kotlin
suspend fun main() {
    println("Before")
    suspendCoroutine<Unit> { continuation ->
        continuation.resume(Unit)
    }
    println("After")
}
```

이렇게 하면 suspend 된 직후 resume되기 때문에 After도 호출되게 된다.

> 여기서 즉시 resume된다고 생각할수도 있지만, 실제로는 최적화 작업을 거쳐서 suspension된 함수가 즉시 재실행 되는걸 방지한다.



> Kotlin 1.3 이후부터 `resume()`과 `resumeWithException()` 대신 Result를 파라미터로 받는 `resumeWith()`가 생겼다.
>
> 우리가 사용하는 `resume()`과 `resumeWithException()`은 **표준 라이브러리를 Extension한 함수로, 내부적으로 `resumeWith()`를 호출하는 함수**이다
>
> ``` kotlin
> inline fun <T> Continuation<T>.resume(value: T): Unit =
>     resumeWith(Result.success(value))
> 
> inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =
> 	resumeWith(Result.failure(exception))

또한, suspend 함수는 **다른 Thread에서 실행할수도 있다.**

``` kotlin
suspend fun main() {
    println("Before")
    suspendCoroutine<Unit> { continuation ->
    	thread {
            println("Suspended")
            Thread.sleep(1000)
            continuation.resume(Unit)
            println("Resumed")
        }
    }
    println("After")
}
```

이렇게 하면 다음과 같은 결과가 나온다.

```
// Before
// Suspended
-- 1초 대기 --
// After
// Resumed
```

여기서 주목할 점은 **Thread를 시작하는 것을 함수로 추출하고, CallBack으로 resume을 넘길 수 있다**는 것이다.

``` kotlin
fun invokeAfterSecond(operation: () -> Unit) {
    thread {
        Thread.sleep(1000)
        operation.invoke()
    }
}

suspend fun main() {
    println("Before")
    suspendCoroutine<Unit> { continuation ->
		invokeAfterSecond {
            continuation.resume(Unit)
        }
	}
    println("After")
}
```

위 메커니즘은 잘 돌아가지만 1초 뒤에 없어질 필요 없어질 Thread를 만들게 된다.

Thread는 비싸기 때문에 낭비해선 안된다.

이를 위해 JVM에서는 `ScheduledExecutorService`를 지원한다.

``` kotlin
private val executor =
	Executors.newSingleThreadScheduledExecutor {
        Thread(it, "scheduler")
        	.apply { isDaemon = true }
    }

suspend fun delay(time: Long): Unit =
	suspendCoroutine { cont ->
		executor.schedule({
            cont.resume(Unit)
        }, time, TimeUnit.MILLISECONDS)
    }

suspend fun main() {
    println("Before")
    delay(1000)
    println("After")
}
```

물론 아직 executor는 Thread를 사용하지만, **모든 Coroutine을 위한 하나의 Thread**일 뿐이다.

매 `delay()`요청마다 Thread를 만드는 것 보다 훨씬 낫다.

이것이 Koroutine이 `delay()`를 구현한 방식이다.

