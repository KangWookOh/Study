# Transaction

### 소개

---

우리가 기본적으로 알고있는 Transaction이란 **데이터베이스의 상태를 변화시키기 위한 작업의 단위**를 의미한다.

하나의 트랜잭션은 취소시킬 수 있고, 문제가 발생하지 않았다면 적용시킬 수 있다.



Spring에서 트랜잭션은 Database와 비슷하지만 별개로 작동하는 AOP 기술이다.

크게 **`@Transactional` 어노테이션을 이용하는 방법과 설정 파일을 이용하는 방법**으로 나뉘어 사용할 수 있다.



### 트랜잭션의 특징

---

| 종류                       | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| Atomicity(원자성)          | 트랜잭션의 연산은 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 한다. |
| Consistency(일관성)        | 트랜잭션이 완료되면 일관성 있게 DB에 반영해야 한다.          |
| Isolation(독립성, 격리성)  | 트랜잭션은 독립적으로 처리되어야 하고 각각의 트랜잭션은 간섭할 수 없다. |
| Durability(영속성, 지속성) | 완료된 트랜잭션은 영구적으로 지속되어야 한다.                |

이러한 **트랜잭션의 특징들은 100% 지켜지지 못한다.**

왜냐하면 특징들을 완전히 지키려 하면 **동시성이 굉장히 떨어지기 때문이다.**

> 동시성이란 하나의 프로세스에서 많은것을 처리하는 것이다.

그렇기 때문에 DBMS는 다음과 같은 특징들을 다 지키지는 못하고 **격리 수준**이라는 것을 통해 원칙을 덜 지키고 동시성을 얻는다.



### 트랜잭션의 상태

---

트랜잭션의 상태는 크게 5개로 나뉠 수 있다.

![Transaction Status](./images/transaction_status.png)

| 이름      | 설명                                                         |
| --------- | ------------------------------------------------------------ |
| 활동      | 말 그대로 트랜잭션이 활동중인 상태로, 다른 모든 상태의 시작이다. |
| 부분 완료 | 트랜잭션이 성공적으로 수행되었지만, Commit을 수행하기 직전의 상태이다. |
| 완료      | 부분 완료 상태에서 Commit 연산을 수행한 상태이다.            |
| 실패      | 트랜잭션의 실행 도중 오류가 발생하여 중지된 상태이다.        |
| 철회      | 비정상적으로 종료된 트랜잭션을 적용하지 않기 위해 ROLLBACK 연산을 수행한 상태이다. |



### 트랜잭션의 격리 수준

---

트랜잭션의 격리 수준이란, **여러 트랜잭션이 있을 때 특정 트랜잭션이 다른 트랜잭션을 변경 및 조회할 수 있도록 허용할지 말지**를 결정하는 것이다.

트랜잭션의 격리 수준에는 4가지가 있다.

> 격리 수준은 `ANSI/ISO`에서 정한 4가지가 있다.



#### Read UnCommitted

각 트랜잭션에서 변경 내용이 commit 또는 rollback 여부에 상관 없이 값을 읽을 수 있다.

문제가 많기 때문에 사용하지 않기를 권장한다.

> 트랜잭션의 작업이 완료되지 않았는데 다른 트랜잭션에서 변경된 값을 볼 수 있다.
>
> 따라서 `Dirty Read`현상이 발생한다.

<img src="./images/transaction_isol_uncommit.png" alt="Transaction Read Uncommited" style="zoom:50%;" />

위 그림과 같이 다른 트랜잭션이 수정되었을 때 커밋되지 않아도 해당 트랜잭션에서 수정된 값을 읽을 수 있다.



#### Read Committed

관계형 데이터베이스에서 주로 사용하고 있는 방법이다.

`Dirty Read`현상이 발생하지 않는다.



실제 테이블이 아닌, **Undo 영역에서 백업된 정보에서 값을 가져온다**.

> Undo 영역이란 롤백, 복구를 위한 영역이다.
>
> 따라서 트랜잭션의 이전 정보를 담고 있기 때문에, Undo 영역에서 백업된 정보는 **트랜잭션 이전의 정보**이다.

<img src="./images/transaction_isol_commit1.png" alt="Transaction Status" style="zoom:50%;" />

하지만 이러한 방식에도 문제는 존재한다.

하지만 **하나의 트랜잭션에서 같은 SQL을 발생시켰음에도 다른 결과가 반환**된다.

따라서 `Repeatable Read`의 정합성에 어긋난다.

<img src="./images/transaction_isol_commit2.png" alt="Transaction Status" style="zoom:50%;" />



#### Repeatable Read

Repeatable Read는 하나의 트랜잭션에서 **Read 작업을 여러번 수행하더라도 같은 결과를 반환하는도록 보장하는 방법**이다.

Repeatable Read는 처음 Read 작업을 했을 때, **Snapshot을 구축한다.**

그리고 그 이후부터, 직접 접근해서 정보를 찾는게 아닌, **스냅샷에서 정보를 찾게 된다.**

그렇기 때문에 하나의 트랜잭션에서는 하나의 스냅샷을 이용하기 때문에 항상 같은 정보를 유지할 수 있다.

> 참고로 해당 트랜잭션에서 Update나 Insert, Delete 작업을 수행하게 되면 스냅샷 정보가 변경된다.





A와 B 트랜잭션이 있다고 가정하면, 다음과 같은 순서를 거친다.

1. A 트랜잭션 생성(id = 1)

2. B 트랜잭션 생성(id = 2)

3. B 트랜잭션에서 a를 b로 수정한다.

4. A 트랜잭션에서 B 트랜잭션에 접근한다.

   A 트랜잭션의 id가 B 트랜잭션보다 작기 때문에 **변경 사항이 적용된 채로 반환된다.**

5. B 트랜잭션에서 A 트랜잭션으로 접근한다.

   B 트랜잭션의 id가 A 트랜잭션보다 작기 때문에 

   