# 4.2.1 Choreography Saga

주로 이벤트 교환 방식으로 통신하며, **의사 순서의 결정을 참여자에게 위임**하는 사가의 일종이다.

이 방식은 Saga 참여자가 할 일을 알려주는 중앙 관리자가 따로 없고, **사가 참여자끼리 이벤트를 구독**해서 반응하는 방식이다.

## Choreography 방식으로 주문 Saga 구현

먼저 전체적인 흐름을 그림으로 보면 다음과 같다.

![img](../../images/163.jpeg)

조금 복잡해보이지만, 다음과 같은 순서로 실행된다고 보면 된다.

1. **주문 서비스**
   1. 승인 대기중인 주문을 생성한다.
   2. 주문 이벤트에 주문이 생성되었다는 이벤트를 발행한다.
2. **소비자 서비스**
   1. 주문이 생성되었다는 이벤트를 수신한다.
   2. 해당 소비자가 주문을 생성할 수 있는지 검증한다.
   3. 만약 할 수 있다면 소비자 이벤트에 소비자 확인 이벤트를 발행한다.
3. **주방 서비스**
   1. 주문이 생성되었다는 이벤트를 수신한다.
   2. 주문 내역을 확인하고, 티켓을 보류중인 상태로 생성한다.
   3. 티켓 이벤트에 티켓이 생성되었다는 이벤트를 발행한다.
4. **회계 서비스**
   1. 주문이 생성되었다는 이벤트를 받는다.
   2. 신용카드 승인을 보류 상태로 생성한다.
5. **회계 서비스**
   1. 티켓 생성/소비자 확인 이벤트를 받는다.
   2. 소비자 신용카드에서 결제를 한다.
   3. 신용카드가 승인되었다는 이벤트를 발행한다.
6. **주방 서비스**
   1. 신용카드 승인 이벤트를 수신한다.
   2. 티켓의 상태를 승인 대기중 상태로 변경한다.
7. **주문 서비스**
   1. 신용카드 승인 이벤트를 수신한다.
   2. 주문 상태를 승인됨 상태로 변경한다.
   3. 주문 승인됨 이벤트를 발행한다.

<br>

만약 각 트랜잭션마다 실패 이벤트가 발행되게 되면 Saga는 **보상 트랜잭션을 실행**해야 한다.

예를 들어 `5. 회계 서비스`에서 소비자의 신용카드 승인이 거부될 경우 이벤트 순서는 다음과 같다.

![img](../../images/165.jpeg)

> 당연히 `4. 회계 서비스`까지는 똑같다.

1. **주문 서비스**
   1. 승인 대기중인 주문을 생성한다.
   2. 주문 이벤트에 주문이 생성되었다는 이벤트를 발행한다.
2. **소비자 서비스**
   1. 주문이 생성되었다는 이벤트를 수신한다.
   2. 해당 소비자가 주문을 생성할 수 있는지 검증한다.
   3. 만약 할 수 있다면 소비자 이벤트에 소비자 확인 이벤트를 발행한다.
3. **주방 서비스**
   1. 주문이 생성되었다는 이벤트를 수신한다.
   2. 주문 내역을 확인하고, 티켓을 보류중인 상태로 생성한다.
   3. 티켓 이벤트에 티켓이 생성되었다는 이벤트를 발행한다.
4. **회계 서비스**
   1. 주문이 생성되었다는 이벤트를 받는다.
   2. 신용카드 승인을 보류 상태로 생성한다.
5. **회계 서비스**
   1. 티켓 생성/소비자 확인 이벤트를 받는다.
   2. 소비자 신용카드에서 결제를 한다.
   3. 신용카드가 거부되었다는 이벤트를 발행한다.
6. **주방 서비스**
   1. 신용카드 거부 이벤트를 수신한다.
   2. 티켓의 상태를 거절됨 상태로 변경한다.
7. **주문 서비스**
   1. 신용카드 거부 이벤트를 수신한다.
   2. 주문 상태를 거절됨 상태로 변경한다.

## 신뢰할 수 있는 이벤트 기반 통신

Choreography 방식의 Saga에서는 두가지 통신 이슈를 해결해야 한다.

1. **자신의 DB를 Update하고 같은 트랜잭션에서 메세지를 발행**해야 한다.

   즉 앞에서 설명했던 Transactional Messaging을 사용해야 한다.

   

2. **Saga 참여자들은 수신한 이벤트와 자신의 데이터 간의 연관 관계를 맺어야 한다.**

   즉 DB 외래키와 같이 주문과 소비자, 주문과 티켓 등 데이터간의 연관 관계를 가져야 한다.

   이를 해결하기 위해 이벤트를 발행할 때 ID값을 포함해서 이벤트를 발행한다.

   즉 만약 주문이 생성되었다는 이벤트를 발행할 때에는 주문 ID를 메세지에 담고, 주방 서비스에서는 이를 통해 티켓을 생성하게 된다.

## Choreography 방식의 장단점

### 장점

- **단순함:** 단순히 이벤트를 발행하기만 하면 된다.
- **낮은 결합도** 이벤트를 구독할 뿐 다른 서비스를 직접적으로 알 필요가 없다.

### 단점

- **높은 이해 난이도:** 여러 서비스에 구현 로직들이 흩어져있기 때문에 Saga가 전반적으로 어떤 흐름을 가지고 있는지 파악하기 힘들다.

- **서비스간의 순환 의존성 문제 가능성:** 참여자가 서로를 구독하기 때문에 순환 의존성이 발생할수도 있다.

  반드시 문제가 생기는건 아니지만, 잠재적 설계 취약점이 될 수 있다.

- **강결합의 위험성:** 장점으로 낮은 결합도를 가지고 있지만, 회계 서비스와 같은 경우에는 과금/환불을 하는 모든 이벤트를 구독해야 한다.

  따라서 이 서비스는 주문 서비스의 주문과 생명 주기가 맞몰릴 수도 있다.

위와 같은 문제점들 때문에 복잡한 사가에서는 주로 Orchestration 방식을 사용한다.