# Saga에서의 격리성

ACID에서 Isolation이란 **동시에 실행된 트랜잭션에서 쿼리의 동일함을 보장하는 속성**이다.

이로 인해서 개발자는 동시에 실행되는 여러 트랜잭션들이 실행되는 상황 속에서 비지니스 로직을 비교적 쉽게 작성할 수 있다.

<br>

그런데 **Saga에서는 격리성 이라는 속성이 존재하지 않는다.**

따라서 Saga에서의 ACID는 다음과 같다.

- **Atomicity:** Saga는 트랜잭션을 모두 완수하거나, 모두 Undo한다.
- **Consistency:** 서비스 내의 참조 무결성 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리해 준다.
- **Isolation:** 존재하지 않음
- **Durability:** 로컬DB에 의존한다.

따라서 하나의 Saga가 실행중일 때 다른 Saga가 데이터를 바꿔치기 할수도 있고, 하나의 Saga에서 수정을 하기 전의 데이터를 다른 Saga가 읽을수도 있다.

따라서 일관성이 위협받을 수도 있다.

> 예를 들면 한 Saga에서 Order를 생성중일때, Order는 승인 대기중인 상태로 Order서비스의 LocalDB에 존재하게 된다.
>
> 이 때 다른 Saga가 Order 목록을 조회하게 되면 승인 대기중인 Order도 함께 보여지게 된다.
>
> 하지만 이때 Order 생성 Saga가 RollBack된다면 일관성이 위협받게 된다.

비격리는 절대 용납되지 않는 규칙이 아니다.

완전한 비격리를 구현하려 하면 성능이 많이 떨어지게 되서 어느정도 성능과 타협해서 격리 수준을 정하는게 일반적이다.

# 4.3.1 Arnomaly(이상) 개요

비격리로 인한 이상현상은 여러가지 종류가 있다.

## 소실된 업데이트

소실된 업데이트란 **한 Saga의 변경사항을 다른 Saga가 덮어쓸 때 발생**하는 상황이다.

다음과 같은 상황에서 발생한다.

1. 주문 생성 Saga에서 주문을 생성한다.
2. 주문 생성 Saga 실행 중 주문 취소 Saga가 실행된다.
3. 주문 취소 Saga에서 주문을 취소 상태로 변경한다.
4. 주문 생성 Saga 마지막에 주문을 승인 상태로 바꾼다.

결국 고객은 **주문을 취소했음에도 주문이 승인 상태로 변경**되는 문제가 생긴다.

## Dirty Read

Dirty Read는 **한 Saga가 수정중인 데이터를 다른 Saga가 읽을 때 발생**한다.

예를 들어 다음과 같은 3개의 서비스가 있다고 가정하자

- 통장 잔고를 늘리는 소비자 서비스
- 주문을 취소 상태로 변경하고, 돈을 다시 반환해 주는 주문 취소 서비스

만약 주문 취소 Saga와 주문 생성 Saga가 동시에 실행중 일 때, 만약 주문 취소에 실패하게 되었다.

그러면 다음과 같이 Saga들끼리 꼬여버릴 수도 있다.

1. 주문 취소 Saga가 동작하며 돈 액수를 늘린다.
2. 주문 Saga에서 주문을 하고, 돈 액수를 줄인다.
3. 주문 취소 Saga가 실패하며 돈 액수를 다시 줄이는 보상 트랜잭션이 동작한다.

큰 문제가 없어보일수도 있겠지만, 위 상황에서는 **소비자의 통장 잔고보다 더 비싼 물건을 주문할 수 있다.**

이러한 상황은 큰 문제를 야기할 수 있기 때문에 꼭 피해야 한다.

## Fuzzy/Unrepeatable Read

Fuzzy/Unrepeatable Read는 **하나의 Saga에서 같은 요청으로 조회를 했을 때 결과가 다른 이상 현상**을 의미한다.

A Saga가 Order 목록을 조회했는데 B Saga가 Order를 추가하게 되면 **A Saga가 다음번에 Order 목록을 조회하게 되면 다른 결과가 나오게 된다.**

