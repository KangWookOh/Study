# Overview

MSA를 어떻게 정의해야 할까? 다른 소프트웨어도 그렇지만, 도메인 전문가가 문서화한 요건들과 기존 Application을 시작점으로 삼아야 한다.

전에 말했듯이, 아키텍쳐를 정의하는건 과학보단 예술에 가까워 정답은 없다.

<br>

이번 챕터에선 애플리케이션 아키텍쳐를 정의하는 3단계 프로세스에 대해 설명한다.

과학처럼 따라한다고 되는게 아니기 때문에 실제로 여러 차례 되풀이해야 할 수도 있고, 창의력이 필요할수도 있다.

<br>

![img](https://thebook.io/img/007035/080.jpg)

##  1단계: 애플리케이션 요건을 핵심 요청으로 추출

애플리케이션은 사용자의 요청을 처리하기 위해 존재한다.

따라서 아키텍쳐를 정의하는 첫번째 단계는 **애플리케이션 요건을 핵심 요청으로 추출**하는 것이다.

즉, 사용자가 요구한 조건을 추출해서 요청을 만들어내는 것이다.

<br>

System Operation은 애플리케이션이 처리하는 요청을 추상화 한 것이다.

이번에는 Rest나 gRPC처럼 특정 기술에 종속된게 아니라 추상화된 개념으로 System Operation 을 볼 것이다.

데이터를 업데이트 하는 커맨드나, 데이터를 조회하는 쿼리 모두 해당된다.

> `updateOrder()`과 같은 커맨드, `getOrder()`과 같은 쿼리

각 커맨드의 동작은 추상적인 도메인 모델 관점에서 정의되고, 결국 시스템 작업은 여러 서비스가 협동하는 방식을 표현한 아키텍쳐 시나리오가 된다.

> 즉 쉽게 말해서 각각의 System Operation이란 사용자의 요청을 처리하는 비지니스 로직 정도로 생각하면 된다.
>
> 따라서 사용자가 *데이터 저장을 원한다*고 말하면 `save()` 메소드가 System Operation 이라고 할 수 있다.

<br>

## 2단계: 어떻게 여러 서비스로 분해할지 결정

여러가지 전략을 시도할 수 잇는데, 비지니스 능력에 따라 정의할 수도 있고, DDD의 하위 도메인 별로 구성할수도 있다.

어떻게 되든 결과는 **기술이 아닌 비지니스 개념 중심 서비스**이다.

<br>

## 3단계: 서비스별로 API 정의

먼저 1단계에서 구분한 System Operation을 각 서비스마다 배정해야 한다.

완전히 다른 서비스와 관계를 가지지 않는 서비스도  있을 수 있지만, 다른 서비스들과 통신해야만 하는 서비스도 있다.

이때 여러 서비스들 간의 통신 방법을 정해야 하는데, 대부분 서비스에서는 **추가적인 기술**을 두는 형태를 사용할 것이다.

<br>

## 분해 과정에서의 문제점

- **네트워크 지연: **서비스 간의 통신이 너무 잦아 분해하기 힘든 경우도 존재한다.

- **서비스 간 동기 통신으로 인한 가용성 저하: **동기적인 통신으로 인해 만약 자신이 클라이언트 입장인데 서버에 문제가 발생하면 내 서비스에 문제가 발생하게 된다.

- **여러 서비스에 걸친 데이터 일관성: **데이터베이스나 서비스가 여러개이기 때문에 데이터 일관성을 지키기 어렵다.

  보통 Saga 패턴으로 해결한다.

- **만능 클래스: **하나의 클래스가 너무 많은 책임을 지니고 있는 상황을 의미한다.

<br>

# 2.2.1 System Operation 식별

애플리케이션 아키텍쳐를 정의하는 첫 걸음은 System Operation을 정의하는 것이다.

이것을 위해서는 사용자 스토리와 사용자 시나리오 등의 애플리케이션 요구 사항들이 필요하다.

우리는 `Applying UML and Patterns` 라는 책의 객체 지향 설계 프로세스에서 영감을 받아 만들어진 2단계 프로세스로 정의할 것이다.

![img](https://thebook.io/img/007035/082.jpg)

먼저 고수준의 도메인 모델에서 정의하고, 2단계에서 작업들을 분류해서 동작을 Domain Model 관점에서 기술한다.

**Domain Model은 주로 사용자 스토리의 명사에서 도출**된다.

> 5장에서 나오는 Event Storming 이라는 기법을 사용해도 된다.

**System Operation은 주로 동사에서 도출**하며, 각각 **하나 이상의 도메인 객체와, 그들 사이의 관계로 기술**한다.

> 여기서는 *주문을 하고싶다*라는 동사에 의해 `createOrder()`이라는 System Operation이 파생되었다.

System Operation은 도메인 모델에 관여할 수 있고, 모델간의 관계를 끊을 수 있다.

<br>

## 고수준 도메인 모델 작성

System Operation을 정의하기 전에 고수준의 애플리케이션 도메인 모델을 먼저 정의해 보아야 한다.

최종 구현보단 간단하지만, 나중에 모델을 작성할 때 도움이 된다.

> 이렇게 간단하게 구현한 모델은 단순하다.
>
> 원래 도메인 모델이 하나뿐인 서비스는 존재하지 않는다.

<br>

도메인 모델은 스토리에서 명사를 도출하고, 도메인 전문가와 상담해서 만들 수 있다.

예를 들어 *주문하기*라는 스토리는 다음과 같이 확장할 수 있다.

```
전제(Given)

소비자가 있다.

음식점이 있다.

음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다.

주문 총액이 음식점의 최소 주문량 조건에 부합한다.

 

조건(When)

소비자가 음식점에 음식을 주문한다.

 

결과(Then)

소비자 신용카드가 승인된다.

주문이 PENDING_ACCEPTANCE 상태로 생성된다.

생성된 주문이 소비자와 연관된다.

생성된 주문이 음식점과 연관된다
```

여기서 명사를 보면 Consumer, Order, Restaurant 등 다양한 클래스가 필요하다.

마찬가지로 주문 접수는 다음과 같이 확장할 수 있다.

``` 
전제(Given)

현재 주문은 PENDING_ACCEPTANCE 상태다.

주문 배달 가능한 배달원이 있다.

 

조건(When)

주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다.

 

결과(Then)

주문 상태가 ACCEPTED로 변경된다.

주문의 promiseByTime 값을 음식점이 준비하기로 약속한 시간으로 업데이트한다.

주문을 배달할 배달원을 배정한다.
```

위 시나리오를 보면 Courier, Delivery가 필요할 것 같다.

이렇게 분석을 계속하다 보면 Address와 같이 다른 클래스들도 도출될 수 있다.

![img](https://thebook.io/img/007035/084.jpg)

- **Consumer: **주문을 하는 소비자

- **Order: **소비자가 한 주문. 어떤 주문인지 나타내며 상태를 추적합니다.

- **OrderLineItem: **Order의 품목

- **DeliveryInfo: **주문을 배달할 시간/장소

- **Restaurant: **배달할 주문을 준비하는 음식점

- **MenuItem: **음식점의 메뉴 항목

- **Courier: **주문을 배달하는 배달원. 배달원의 가용성 및 현재 위치를 추적합니다.

- **Address: **소비자 또는 음식점의 주소

- **Location: **배달원의 위치(위도/경도)

<br>

## System Operation 정의

애플리케이션이 어떤 요청을 처리할지 구분하는 단계.

시스템 작업은 다음 두 종류로 나뉜다.

- **Command: **데이터 생성, 수정, 삭제를 담당
- **Query: **데이터 읽기를 담당

<br>

System Operation은 결국 Rest, RPC로 구현되겠지만, 일단 추상적으로 특정 기술에 종속되지 않도록 생각한다.

<br>

### 커맨드 식별

System Command를 식별하기 위해서는 **사용자 스토리나 시나리오에 포함된 동사를 분석**해야 한다.

예를 들어 소비자는 *주문 생성*이라는 동사를 가지고 있고, 따라서 `createOrder()`과 같은 커맨드가 발생하게 된다.

<br>

커맨드는 **매개변수, 반환 값, 동작 방식의 명세를 도메인 모델 클래스를 사용해서 정의**해야 한다.

예를 들면 다음과 같다.

| 종류      | 명세                                                         |
| --------- | ------------------------------------------------------------ |
| 작업      | createOrder(소비자 ID, 결제 수단, 배달 주소, 배달 시각, 음식점 ID, 주문 품목) |
| 반환값    | orderId, …                                                   |
| 선행 조건 | 소비자가 존재하고 주문을 할 수 있다.<br />주문 품목은 음식점의 메뉴 항목에 들어 있다.<br />배달 주소/시각은 음식점에서 서비스할 수 있다. |
| 후행 조건 | 소비자 신용카드는 주문 금액만큼 승인 처리되었다.<br />주문은 PENDING_ACCEPTANCE 상태로 생성되었다. |

선행 조건은 시나리오의 Given을, 후행 조건은 시나리오의 Then을 나타낸다.

System Operation 호출 시 **선행 조건을 확인한 후에, 후행 조건을 만족하도록 한다**

<br>

고수준의 Domain Model과 System Operation을 보면 애플리케이션이 어떤 일을 하는지 알 수 있기 때문에 아키텍쳐를 정의하는 데에 유용하다.

**각 시스템의 동작은 도메인 모델 중심으로 기술**된다.

따라서 각각의 중요한 System Operation은 아키텍쳐를 설명할 때 중요한 시나리오를 나타내 준다.

<br>

System Operation을 정의한 애플리케이션 서비스를 분류해야 한다.

여기에는 정답이 없지만, 상황에 따라 다양한 전략을 사용할 수 있다.

<br>

# 서비스 정의 - 비지니스 능력 패턴 별 분해

MSA를 구축하는 첫  전략은 비지니스 능력에 따라 분해하는 방법이다.

비지니스 아키텍쳐 모델링 개념인 Business Capability는 **비지니스가 가치를 가지게 하기 위한 일**이다.

비지니스 능력은 업종마다 다른데, 보험 회사라면 클레임 관리, 과금 등의 능력을 지니고 있을 것이다.

<br>

## 비지니스 능력은 곧 그 조직이 하는 일이다.

비지니스 능력을 보면 해당 조직의 비지니스를 알 수 있다.

조직이 비지니스를 하는 방법은 매번마다 다르고, 계속해서 바뀌기도 하지만 비지니스 능력은 웬만하면 바뀌지 않는다.

특히 비지니스 처리를 자동화 하는 요즘엔 더 그렇다.

우리가 은행에서 직접 돈을 예금하기도 했지만, 요즘은 거의 핸드폰을 많이 사용한다.

물론 현금을 사용하는 방법은 웬만해선 없어지지 않지만, 처리하는 방법은 바뀔 수 잇다.

<br>

## 비지니스 능력 구분

한 조직의 비지니스 능력은 조직의 목표, 구조, 프로세스를 분석하여 결정한다.

사실 기술보단 비지니스 위주인 서비스 라고도 할 수 있다.

비지니스 능력 명세는 다양한 컴포넌트로 구성되는데, 예를 들어 보험사의 증권 인수라는 능력의 입력은 소비자 신청서, 출력은 승인과 단가가 된다.

<br>

비지니스 능력은 보통 특정 비지니스 객체에 집중하며, 여러개의 하위 능력으로 분해할 수 있다.

예를 들면 클레임 이라는 비지니스 객체는 클레임 관리 능력을 중심으로 클레임 정보 관리, 클레임 검토, 클레임 처리 등의 하위 능력이 있다.

<br>
FTGO의 비지니스 능력은 다음과 같다.

- **공급자 관리**
  - 배달원 관리: 배달 정보 관리
  - 음식점 정보 관리: 음식점 메뉴, 위치, 영업 시간, 기타 정보 관리
- **소비자 관리**: 소비자에 관한 정보 관리
- **주문 접수 및 이행**
  - 주문 관리: 소비자가 주문을 생성/관리할 수 있게 합니다.
  - 음식점 주문 관리: 음식점의 주문 준비 상태를 관리
  - 로지스틱스(logistics, 실행 계획)
  - 배달원 가용성 관리: 배달원이 배달 가능한지 실시간 관리
  - 배달 관리: 주문을 소비자에게 배달
- **회계**
  - 소비자 회계: 소비자 과금 관리
  - 음식점 회계: 음식점 지불 관리
  - 배달원 회계: 배달원 지불 관리

이제 이 비지니스 능력으로 서비스를 정의해 보자

<br>

## 비지니스 능력을 서비스로

비지니스 능력을 구분했으니, 이제 그 능력에 따라 연관된 능력 그룹에 맞춰 서비스를 정의해 준다.

![img](https://thebook.io/img/007035/090.jpg)

위 그림은 FTGO 서비스에서 비지니스 능력을 애플리케이션 서비스에 매핑한 것으로, 회계 능력과 같이 최상위 능력이 바로 매핑된 경우도 있다.

하지만 웬만하면 하위 능력이 서비스에 매핑되어 있는걸 알 수 있다.

<br>

분리하는 방법은 주관적이지만, 책의 저자는 다음과 같이 생각했다.

- 공급자 관리 능력의 두 하위 능력은 각각의 서비스로 매핑했다.

  음식점과 배달원은 성격이 다르기 때문이다.

- 주문 접수 및 이행 능력은 서비스마다 프로세스 단계가 다르게 때문에 3개의 서비스로 매핑시켜 줬다.

  배달원 가용성 관리와 배달 관리는 연관이 있어 하나의 서비스로 묶여줬다.

- 회계 능력은 다 비슷하기 때문에 자체 서비스에 매핑해 줬다.

비지니스 능력은 거의 변하지 않기 때문에 서비스를 비지니스 능력에 따라 구성하면 **안정적인 아키텍쳐**를 구축할 수 있다.

나중에 비지니스 요건이 달라져도, 각각의 컴포넌트들은 아키텍쳐를 그대로 둔 채로 발전시킬 수 있다.

<br>

위 서비스는 단순한 설계도에 불과하다.

우리가 애플리케이션의 도메인에 대해 이해할수록 서비스도 점점 더 발전할 것이다.

특히 아키텍쳐를 정의할 때 각 핵심 서비스와 나머지 서비스들이 어떻게 협동하는지 살피는게 중요하다.

예를 들어 특정 서비스에선 통신이 너무 많아 분해하는게 비효율적이라 서비스를 결합할 수도 있다.

반대로 어떤건 여러개로 나누는게 편할정도로 복잡한 경우도 있다.

<br>

어쨋든 이러한 문제들은 조금 이따 다시 다룰 예정이다.
