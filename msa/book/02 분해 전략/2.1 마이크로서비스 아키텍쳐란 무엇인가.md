# 2.1.1 소프트웨어 아키텍쳐의 정의와 중요성

많은 개발자들이 더 나은 아키텍쳐를 꿈꾸며 연구하고 노력하고 있다.

그런데 아키텍쳐가 뭐길래 왜 그렇게 많은 개발자들이 더 나은 아키텍쳐를 꿈꾸고 있는걸까?

<br>

## 소프트웨어 아키텍쳐의 정의

소프트웨어 아키텍쳐는 다양한데다가, 소프트웨어의 품질에 영향을 주기 때문에 신중하게 선택해야 한다.

마이크로 서비스 아키텍쳐도 소프트웨어 아키텍쳐중 일종으로 관리, 테스트, 배포성이 높은 아키텍쳐 이다.

<br>

소프트웨어 아키텍쳐에 대해 정의하는 문구는 많지만, 그 중 `Len Bass` 라는 사람이 내린 정의는 다음과 같다.

*컴퓨팅 시스템의 소프트웨어 아키텍쳐는 소프트웨어 엘리먼트와 그들과의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.*

추상적이라 이해하기 힘들 수 있지만, 핵심은 **애플리케이션 아키텍쳐가 여러 엘리먼트로 분해된다는 것과 엘리먼트 간의 연관성**이다.

분해가 중요한 이유는 다음과 같다.

- **업무와 지식의 분할 :** 전문 지식을 가진 사람들이 함께 애플리케이션 작업을 할 수 있다.	(?)
- **소프트웨어 엘리먼트의 상호작용을 기술한다.**

<br>

## 소프트웨어 아키텍쳐의 4+1 뷰 모델

애플리케이션 아키텍쳐를 바라보는 관점은 다양하다.

`Phillip Krutchen`은 소프트웨어 아키텍쳐가 4+1 모델 이라는 유명한 논문을 발표했다.

4+1 모델은 **아키텍쳐를 바라보는 4가지 관점**을 정의한다.

각각의 뷰는 아키텍쳐의 특정 측면을 기술하고, 다른 소프트웨어 엘리먼트와의 관계를 기술한다.

<br>

![img](https://thebook.io/img/007035/071.jpg)

<br>

### Logical View 

개발자가 작성한 소프트웨어 엘리먼트. 즉 **개발자의 관점**이다.

객체 지향 언어라면 클래스, 패키지에 해당하고, **클래스와 패키지나 상속이나 종속성 같은 것들 사이의 관계를 의미한다.**

<br>

### Implementation View

빌드 시스템의 결과물. 즉 Java라면 JAR이나 WAR 파일과 같이 *실행 가능한 파일*이나 *패키징된 코드*를 의미한다.

**모듈간의 Dependency나 Component와 Module간의 조합 관계**가 포함된다.

<br>

### Process View

Runtime Component로, **각각의 개별 프로세스가 엘리먼트**이고, **IPC가 프로세스 간의 관계**를 나타낸다.

<br>

### Deployment View

프로세스가 머신에 매핑되는 방법.

**물리/가상 머신과 프로세스가 엘리먼트**이고, **머신간의 관계인 네트워킹, 프로세스와 머신간의 관계**가 이 View에서 기술된다.

<br>

### Scenario

4개의 관점 외에도 하나의 관점이 더 있는데, **뷰를 구동시키는 Scenario가 있다**

<br>

이렇듯 4+1 View Model은 **아키텍쳐를 명쾌하게 하기 위한 수단**이다.

4개의 View들은 **아키텍쳐 측면**을, Scenario는 **View의 엘리먼트가 협동하는 과정**을 명시한다.

<br>

## 아키텍쳐의 중요성

애플리케이션의 요구 조건은 크게 두 종류로 나뉜다.

- **기능적 요구 조건: **보통 Use Case나 사용자의 Story 포맷으로 작성한다. 아키텍쳐와는 거의 무관하다.

- **서비스의 품질에 관한 요구 조건: **반응성, 안정성과 같이 ~성 으로 끝나는 요구 조건들. 아키텍쳐는 이 조건들을 충족할 수 있게 설계해야 한다. 확장성, 신뢰성 외에도 관리성, 테스트성, 배포성 또한 품질에 해당된다.

  물론 아키텍쳐들은 각각 Trade-Off가 있기 때문에 정답은 없다. 하지만 자신에 상황에 맞는 아키텍쳐를 선택함으로써 원하는 품질 요건을 만족시킬 수 있다.

<br>

# 2.1.2 아키텍쳐 스타일 개요

아키텍쳐 스타일 개념은 특성과 상황에 따라 다른 양식을 따른다.

`David Garlan`과 `Mary Shaw`는 아키텍쳐 스타일을 다음과 같이 정의한다.

*아키텍쳐 스타일은 체계적인 조직의 관점에서 시스템 군을 정의한다.*

*좀 더 구체적으로 말하면 아키텍쳐 스타일은 해당 스타일로 만들어진 인스턴스에서 사용할 수 있는 Component와 Connector의 용어 사전, 그리고 이들을 조합할 수 있는 제약조건을 결정한다.*

<br>

특정 아키텍쳐 스타일은 엘리먼트(컴포넌트)의 컴포넌트간의 관계(커넥터)의 한정된 팔레트를 제공하며, 이를 토대로 애플리케이션 아키텍쳐의 View를 정의할 수 있다.

> MSA를 예로, 각각의 서비스(엘리먼트)와 커넥터(IPC)들 사이에는 한정된 팔레트(API)를 제공해서 아키텍쳐의 View를 정의할 수 있다.

애플리케이션은 대부분 **아키텍쳐 스타일을 조합**해서 사용한다.

Monoltihic Architecture도 구현 뷰를 하나의 실행 가능한 컴포넌트(JAR)로 구성한 아키텍쳐 스타일 이다.

MSA는 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍쳐 스타일 이다.

<br>

## 계층화 아키텍쳐 스타일

소프트웨어 엘리먼트를 계층별로 구성하는 Layered Architecture는 전형적인 아키텍쳐 스타일 이다.

계층마다 정의된 역할을 분담하고, 계층간의 의존 관계는 아키텍쳐로 제한한다.

따라서 어떤 계층은 하위 계층에만 의존한다.

<br>

계층화 아키텍쳐 에서는 앞에서 배운 4가지 View 모두 적용할 수 있다.

우리가 평소에 사용하던 3계층 아키텍쳐가 계층화 아키텍쳐를 Logical View에 적용한 사례로, 애플리케이션을 다음과 같이 분리한 경우이다.

- **표현 계층: **사용자 인터페이스 또는 API가 구현된 계층
- **비지니스 로직 계층: **비지니스 로직이 구현된 계층
- **영속화 계층: **DB 상호작용 로직이 구현된 계층

많이 사용되는 계층화 아키텍쳐 이지만, 몇가지 흠이 있다.

1. **표현 계층이 하나밖에 없다: **하나의 애플리케이션을 호출하는 시스템이 여러개일 수 있다.
2. **영속화 계층이 하나뿐이다: ** 애플리케이션이 작용하는 DB가 여러개일 수 있다.
3. **비지니스 로직 계층이 영속화 계층에 의존한다: **따라서 DB없이 비지니스 로직의 테스트가 불가능하다.

또한 계층화 아키텍쳐에선 의존 관계를 잘못 나타는 경우도 있다.

일반적으로 비지니스 로직 계층은 인터페이스나 데이터 접근이 가능한 인터페이스 레포지토리를 정의하고,

영속화 계층은 레포지토리 인터페이스를 구현한 DAO 클래스를 정의한다.

즉, 실제 의존 관계가 정 반대로 되어있다.

<br>

## 육각형 아키텍쳐 스타일

육각형 아키텍쳐 스타일은 위에서 계층형 아키텍쳐의 문제점을 보완하기 위해서 등장한 **논리 뷰를 비지니스 로직 중심으로 구성**하는 아키텍쳐 스타일 이다.

애플리케이션의 표현 계층 대신 비지니스 로직을 호출해서 외부의 요청을 처리하는 **Inbound Adapters**를 두고,

비지니스 로직에 의해 호출되는 외부 애플리케이션을 호출하는 **Outbound Adapters**를 둔다.

**비지니스 로직이 어댑터들에게 전혀 의존하지 않고, 오히려 어댑터가 비지니스 로직에 의존**한다.

<br>

비지니스 로직에는 하나 이상의 포트가 있고, 포트는 비지니스 로직이 외부와 상호작용 하는 방법이 정의된 Operation이다.

> 여기서 말하는 포트는 우리가 평소에 알던 포트가 아니다.
>
> Java에서 사용하던 인터페이스와 같은 개념 이라고 생각하면 된다.

포트의 종류는 다음과 같다.

- **인바운드 포트: **비지니스 로직이 표출된 API로, 외부 애플리케이션의 요청을 받는 포트.

  예를 들어 public 메소드가 정의된 서비스 인터페이스 라고 생각하면 된다.

- **아웃바운드 포트: **비지니스 로직이 외부 시스템을 호출하는 방법에 관한 것.

  예를 들어 데이터 접근이 정의된 레포지토리 인터페이스를 의미한다.

![img](https://thebook.io/img/007035/074.jpg)

위 그림에서 볼 수 있다싶이, **어댑터가 비지니스 로직을 감싸고 있다.**

- **인바운드 어댑터: **외부의 요청을 인바운드 포트를 호출해서 처리한다.

  예를 들어 Rest Endpoint나 MVC Controller, Message Broker 등이 있다.

- **아웃바운드 어댑터: **비지니스 로직에서 들어온 요청을 외부 서비스를 호출해서 처리해 준다.

  예를 들어 DB 작업이 구현된 DAO나 원격 서비스를 호출하는 Proxy 클래스 등이 있다.

<br>

이러한 방식의 가장 큰 장점은 **비지니스 로직의 표현/데이터 접근 로직이 어댑터와 분리**되어 있기 때문에 비지니스 로직이 **다른 계층에 의존하지 않는다**는 점 이다.

<br>

제각기 특정 API나 UI가 구현된 인바운드 어댑터가 비지니스 로직을 호출하고, 비지니스 로직은 다양한 외부 시스템을 호출하는 아웃바운드 어댑터를 호출하는 구조이다.

육각형 아키텍쳐는 MSA의 각각 서비들에게 적합한 아키텍쳐 이다.

계층화`(표현/비지니스 로직/영속화)`와 육각형`(포트, 어댑터, 비지니스 로직)` 아키텍쳐 모두 3계층 아키텍쳐 형태로, Logical View를 구성한다.

또한 아키텍쳐 구성 요소를 정의해서 그들간의 제약 조건을 둔다는 공통점이 있다.

