서비스에 적용 가능한 IPC 기술은 종류가 많다.

- HTTP 기반 Rest 통신
- gRPC
- AMQP
- STOMP

또한 메세지 포맷도 JSON, XML이나 Protocol Buffer와 같이 효율이 좋은 포맷까지 다양하다.

<br>

# 3.1.1 상호 작용 스타일

서비스 API에 맞는 IPC를 선택하기 전, **서비스와 클라이언트 사이의 상호작용 스타일**에 대해 이해하는게 좋다.

그래야지 IPC 기술의 세부 내용에 빠져 헤매는걸 방지할 수 있다.

상호 작용 스타일의 선택은 Application의 가용성에도 영향을 미치며, 테스트 전략 수립에도 좋다.

상호 작용 스타일은 두 가지 기준으로 분류할 수 있다.

<br>

먼저 요청을 처리하는 서비스의 개수이다.

- **일대일: **각 클라이언트의 요청을 한 서비스가 처리
- **일대다: **각 클라이언트의 요청을 여러 서비스가 처리

<br>

그리고 동기인지 비동기인지 여부를 선택하면 된다.

- **동기: **클라이언트는 서비스가 즉시 응답하리라 기대하고 Thread를 Blocking한다.
- **비동기: **클라이언트가 블로킹되지 않는다. 응답은 굳이 즉시 전송될 필요도 없다.

<br>

각각 스타일에 따른 종류는 다음과 같다.

| 서비스 | 일대일                            | 일대다                        |
| ------ | --------------------------------- | ----------------------------- |
| 동기   | Request/Response                  | X                             |
| 비동기 | 비동기 요청/응답<br />단방향 알림 | pub/sub<br />발행/비동기 응답 |

<br>

## 일대일 상호작용

### Request/Response

클라이언트는 서비스에 요청을 하고 응답을 기다린다.

클라이언트는 응답이 제때 도착하리라 기대하고, 대기 중 **블로킹**된다.

결국 **서비스가 강하게 결합**된다.

<br>

### Asynchronous Request/Response

클라이언트는 서비스에 요청을 보내고, 서비스는 **비동기적으로 응답**한다.

클라이언트는 **블로킹하지 않고 서비스는 응답을 오랫동안 하지 않을 수 있다.**

<br>

### One-way Notification

클라이언트는 일방적으로 요청만 하고, 서비스는 응답을 보내지 않는다.

Fire-And-Forget 모델과 비슷하다.

<br>

Synchronous Request/Response는 보통 **IPC 기술에 독립적**인 상호 작용 스타일 이다.

예를 들어, Request/Response Model로 REST 또는 Messaging 통신을 할 수 있다.

이 경우에는 Message Broker로 통신하고 있더라도 **Client는 Blocking**된다.

서비스가 느슨한 결합을 유지하고 있든, 강하게 결합되어 있든 Blocking된다.

> 이 부분은 뒤에서 다시 다룰 에정이다.

<br>

## 일대다 상호 작용

### Publisher/Subscribe

클라이언트는 **메세지를 발행**하고, 여기에 관심이 있는 서비스들이 **메세지를 소비**한다.

관심이 있는 서비스는 있을수도, 없을수도 있다.

<br>

### Publish/Async Response

클라이언트는 **메세지를 발행**하고, **주어진 시간 안에 서비스가 응답하길 기다린다.**

서비스의 응답을 기다린다는 점에서 Pub/Sub 모델과는 다르다.

<br>

# 3.1.2 마이크로서비스 API 정의

Application은 여러 모듈로 구성되며, 모듈마다 클라이언트가 호출할 작업이 정의된 인터페이스가 존재한다.

잘 설계되었다면 유용한 기능은 표출하되, 구현체는 감추어서 클라이언트에게 영향 없이 코드 수정이 가능하다.

<br>

Monolithic Application은 대부분 프로그래밍 언어에 맞게 인터페이스를 지정한다.

예를 들어 자바에선 클라이언트가 호출할 메소드들이 정해져 있고, 클라이언트는 구현체를 직접 바라볼 수 없다.

자바는 정적 타입 언어 이기 때문에 클라이언트와 인터페이스가 다르면 컴파일조차 되지 않는다.

<br>

MSA에서는 API와 인터페이스 모두 중요하다.

서비스 API는 **서비스와 클라이언트 간의 약속**으로, **호출 가능한 Operation과 이벤트**로 구성되어 있다.

Operation은 이름, 매개변수, 반환 타입으로 이루어져 있고, 이벤트는 타입과 필드를 가지고 메세지 채널에 발행되게 된다.

> 3.3절에서 더 자세하게 설명한다.

<br>

문제는 서비스 API가 **단순한 프로그래밍 언어의 일부분이 아니라는 점**이다.

규칙에 따르면 서비스와 클라이언트는 함께 컴파일되지 않는다.

따라서 새 버전의 서비스가 이전 버전과는 호환되지 않는 API를 배포하더라도, **컴파일 에러 없이 런타임에서 조용히 실패**할 것이다.

<br>

어떤 IPC를 선택하는 API를 IDL로 정확하게 정의해야 한다.

> IDL이란 Interface Definition Language로, 어느 언어에 국한되지 않는 방법으로 인터페이스를 표현하는 언어이다.
>
> 이를 통해서 인터페이스를 정의하고, Java와 같은 구현 언어로의 매핑을 지원한다.

API First 방식으로 서비스를 정의하는건 좋은 [자료](http://bit.ly/msp-7)들이 있다.

IDL을 작성한 후에 클라이언트 개발자와 몇번 의논한 후에 API를 정의하고, 서비스를 구현한다.

이렇게 먼저 설계를 하는 방법은 **클라이언트의 요구에 좀 더 부합한 서비스**를 구축할 수 있다.

<br>

API의 내용은 IPC에 의해 결정된다.

메세징으로 통신하는 API는 메세지 채널, 타입, 포맷으로 정의한다.

HTTP는 URL, HTTP Method, Response 포맷으로 구성된다.

