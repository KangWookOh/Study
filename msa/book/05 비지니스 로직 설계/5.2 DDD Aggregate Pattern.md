# 5.2.0 기존의 비지니스 모델

다음은 한 Application의 Domain Model 중 하나이다.

![image-20211010145507788](../../images/image-20211010145507788.png)

서로 연관된 클래스들끼리 그물망처럼 얽힌 전형적인 도메인 모델이다.

Customer, Order, Restaurant 등 각 비지니스 객체에 대응되는 클래스가 존재한다.

하지만 **비지니스 객체들의 경계가 불분명**하다.

예를 들어 Order이라는 비지니스 객체는 어느 클래스에 대응되는 비지니스 객체인지 알기 쉽지 않다.

이러한 불분명한 비지니스 객체는 MSA에서 문제가 생길 가능성이 높기 때문에 조심해야 한다.

# 5.2.1 불분명한 경계 문제

Order 객체가 어떤 작업을 한다고 가정했을 때, 범위가 불분명하다 라는 문제가 있다.

범위가 불분명하다면 여러가지 비지니스 규칙을 지키기 힘들어지게 된다.

예를 들어, *money가 10000을 넘길 수 없다*라는 규칙이 있는 상황에서 한 사용자의 money를 늘리는 요청이 동시에 들어왔다고 가정하자.

이렇게 된다면 money가 10000을 넘기게 되는 상황이 일어날수도 있다.

DDD Aggregate를 사용하면 이 문제를 해결할 수 있다.

# 5.2.2 Aggregate의 분명한 경계

Aggregate는 **한 경계 안에 명확히 들어있는 도메인 객체들**이다.

하나의 Root Entity와 여러개의 다른 엔티티 또는 VO로 구성될 수 있다.

비지니스 객체는 대부분 Aggregate로 모델링하게 된다.

<br>

![image-20211010222027146](../../images/image-20211010222027146.png)

위 그림과 같이 2장에서 대략적으로 설계한 도메인 모델에서 주문, 소비자, 음식점이 각각 Aggregate라고 할 수 있다.

Order를 예로 들면 Order Aggregate는 여러개의 VO로 이루어져 있다.

<br>

Aggregate는 **Domain을 이해하기 쉬운 덩어리 단위로 분해**한다.

또한 작업의 범위를 분명히 해서 조회, 수정, 삭제와 같은 작업의 범위를 분명히 한다.

## Aggregate의 일관된 경계

Aggregate는 **한 Aggregate 전체만을 수정**하기 때문에 **일관성 문제가 해결**된다.

Update를 할 때 작업은 **Aggregate Root Entity의 메소드를 반드시 거치기 때문에 불변성이 강제**된다.

예를 들어 Order의 Version을 수정한다고 했을 때, 항상 Order 엔티티를 거치기 때문에 항상 Version 값은 정합성을 충족하고, Aggregate 단위로 트랜잭션의 Lock이 걸리기 때문에 동시성 측면에서도 일관성이 해결된다.

