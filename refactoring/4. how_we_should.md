# 어떻게 리팩토링 해야 하는가

## 기본 방법

### 테스트 코드

만약 우리가 리팩토링 해야 하는 코드가 테스트 코드가 없다면, 가장 먼저 테스트 코드부터 작성해야 한다.

테스트 코드를 작성하기 가장 좋은 시점은, **프로그래밍을 시작하기 전** 이다.

> 이걸 Test-Driven Development. 즉 테스트 주도 개발이라 한다.
>
> TDD는 테스트 코드를 작성하고, 테스트 코드를 통과하기 위한 소프트웨어를 만드는 것이다.
>
> 1. 테스트 코드를 작성한다.
>
>    반드시 **실패를 포함**하는 테스트 코드가 있어야 한다
>
> 2. 테스트 통과를 위한 **최소한**의 구현 코드를 작성한다.
>
>    가장 큰 목표가 테스트 통과이다.
>
> 3. 구현 코드를 리팩토링 단계에서 개선한다.

#### 테스트 코드의 조건

- 테스트 조건은 각 테스트 코드끼리 상호작용 되어선 안된다.

- 하나의 테스트에서 여러개를 검증하면 안된다.

  하나의 테스트 코드에서 여러개를 검증하게 되면 맨 처음 검증이 실패하면 그 아래의 검증은 테스트도 못하게 된다.

- 경계조건을 검사하자

  보통 테스트 코드들은 자신의 의도대로 만들기 때문에 일반적인 조건에서 테스트를 수행한다.

  하지만 이 조건 범위를 벗어나는 경계지점의 조건들을 테스트에 추가하면 예외 상황 처리를 빠르게 할 수 있다.

### 함수 추출

목적과 구현을 분리 시키기 위해 함수를 분리해 준다.

함수의 코드를 보고 목적을 바로 알 수  있도록 해야 하기 때문에, 최대한 간결하게 해야 한다.

``` java
public OrderInfo getOrderInfo() {
	orderRepository.findById(1)
        .orElseThrow(NotFoundException::new);
    
    return OrderInfo.builder
        .name(order.getName)
        .cost(order.getCost)
        .build();
}
```

이렇게 주문 정보를 가져오는 서비스가 있다고 가정하자.

위 코드는 너무 난잡하고 읽기 어렵기 때문에 아래와 같이 수정할 수 있다.

``` java
public OrderInfo getOrderInfo() {
    Order order = getOrder;
    OrderInfo orderInfo = buildOrder(order);
    return orderInfo;
}

private Order getOrder() {
	return orderRepository.findById(1)
        .orElseThrow(NotFoundException::new);
}

private OrderInfo buildOrder(Order order) {
    return OrderInfo.builder
        .name(order.getName)
        .cost(order.getCost)
        .build();
}
```

이렇게 하면 하나의 메소드는 하나의 역할만 가지며, 메인이 되는 getOrderInfo 메소드는 주문을 가져오고, 그 주문을 build해서 반환하는 읽기 쉬운 코드가 되었다.

#### 함수 인라인

만약 함수 코드 자체가 함수 내용만큼 명확하다면 함수를 제거하는게 오히려 나을 수 있다.

함수 추출이 과도하게 된 경우 위임관계가 복잡해질 수 있기 때문이다

### 변수 추출

우선 다음 예제를 보자

``` java
return Math.max(lists) * Math.min(lists) * 0.7 + 1000;
```

우선 예제로 이정도만 썼지만, 훨씬 복잡한 계산 등을 해야 할 때가 많다.

이러한 표현식은 읽기 어렵기 때문에 코드의 목적을 알아내기 힘들다.



따라서 다음과 같이 변수로 추출해 주는게 좋다.

``` java
Integer max = Math.max(lists);
Integer min = Math.min(lists);
Integer result = max * min * 0.7 + 100;
return result;
```

이렇게 하는 편이 어려운 표현식이 나열된 것 보다 코드의 목적이 명확하다.

> 하나의 함수 내에서만 사용되는 경우 이렇게 추출한다.
>
> 만약 함수를 넘어 문맥에서 통용되는 경우 함수로 추출해 준다.



만약 아래 코드와 같이 원래 표현식과 변수가 다를바 없다면 그냥 인라인을 사용하는게 좋다.

``` java
int basePrice = a.basePrice;
return (basePrice > 1000);
```

``` java
return a.basePrice > 1000;
```

### 함수 선언

함수의 이름이 명확하면 호출문만 봐도 메소드의 목적을 알 수 있다.

좋은 이름이 떠오르지 않았을 때에는 함수의 목적을 주석으로 달아도 된다.

### 변수 캡슐화

데이터의 캡슐화는 데이터를 변경 및 사용하는 코드를 감시할 수 있도록 해준다.

데이터가 널리 사용될수록 캡슐화가 필요하다.

### 변수 이름 변경

좋은 이름의 변수는 작업 로직에서 생각보다 많은걸 설명해 준다.

람다식에서 사용되는 변수는 대체로 쉽게 파악이 가능하기 때문에 한글자로 짓기도 한다.

### 매개변수 객체 만들기

우리가 메소드의 매개변수를 만들 때, 아래와 같은 코드가 있다고 가정하자.

``` java
public void amount(LocalDate startDate, LocalDate endDate);
```

이러한 함수는 읽기 쉬울 수 있지만, 많아지면 많아질수록 읽기 어렵다.

그렇기 때문에 매개변수들은 객체로 묶어서 한번에 사용하는게 좋다.

``` java
public void amount(Term term);
```

이렇게 하는 편이 나중에 알아보기도 쉽고, 매개변수가 줄어 함수 선언이 짫아진다.

> 데이터 객체는 단순히 매개변수를 묶는 것 외에도 여러 메소드를 가질 수 있다.

### 여러 함수를 클래스로 묶기

함수들이 공유하는 공통 데이터가 있는 경우, 하나의 클래스로 묶어주면 공통 데이터 중심으로 긴밀하게 작동할 수 있다.

### 함수 추출

데이터를 입력받아서 함수들로 로직이 생성되는 경우, 하나의 클래스로 묶는게 좋다.

### 단계 분할

서로 다른 두 값을 한번에 다루는 코드가 있다면, 별개의 모듈로 나누는게 좋다.

단계를 쪼개는게 작업하는 사항을 명확하게 드러낼 수 있다.

## 캡슐화

캡슐화는 객체의 속성과 함수를 한군데에 묶어, 공개가 되어야만 하는 필수 요소들만 노출시켜서 내부의 데이터 및 기능을 은닉시키는 방법이다.

캡슐화는 응집도는 강화해 주지만, 결합도는 약화시켜 줘서 객체 지향에서 꼭 필요한 것 이다.

### 레코드 캡슐화

정의된 필드에 직접 참조하는 경우가 많을 때, 캡슐화를 해주는게 좋다.

### 컬렉션 캡슐화

컬렉션은 외부에서 직접 접근하지 못하도록 캡슐화 하는것이 좋다.

### 기본형을 객체로 변환

숫자, 문자와 같은 간단한 데이터라도, 기능이 필요해 지면 객체로 만들어 주는게 좋다.

``` java
String order = "a,b,c,d";
String[] orders = order.split(",")
```

이렇게 변수에 split 이라는 기능이 필요하다면, 객체로 만들어 주는게 좋다.

> 물론 이건 너무 간단한 기능이라 사용하지 않아도 된다.

``` java
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class Order {
    private String order;
    
    public String[] getOrders() {
        return this.order.split(",")
    }
}
```

``` java
Ordeer order = new Order("aa,aa");
String[] orders = order.getOrders();
```

### 임시 변수를 질의함수로 바꾸기

``` java
int basePrice = a + b;
int saledPrice = basePrice * 0.9;
int result = saledPrice * 0.5;
```

위와 같이 긴 표현식을 임시 변수로 조금 더 읽기 좋게 고쳤다.

하지만 아예 함수로 만드는게 좋을때도 있다.

특히 비슷한 계산을 다른 곳에서 수행한다면, 코드의 중복을 줄일 수 있다.

### 클래스 추출

하나의 클래스에 여러가지 연산이나 데이터를 보강하다 보면, 클래스가 너무 커져 복잡해 지게 된다.

만약 하나의 클래스가 너무 복잡하다면 클래스를 분리하는 것이 좋다

### 클래스 인라인

바로 위에서 추출했지만, 분리 후 남은 역할이 거의 없는 경우 다시 인라인 시켜주는게 좋다.

많이 사용되는 클래스 쪽으로 흡수된다.

### 위임 숨기기

캡슐화는 각각의 모듈이 자기 자신에게만 신경쓰고, 다른 시스템에 대해 알 내용을 적게 해준다.

위임 객체의 인터페이스가 변경되면 결합된 모든 코드를 변경해야 한다.

### 알고리즘 교체하기

목적을 